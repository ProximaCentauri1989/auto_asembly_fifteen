//Функция получения случайного состояния игрового поля (размерностю 4x4). Состояния игрового поля, при которых сборка невозможна отсекаются
//Генерируемое поле представлено как одномерный массив.
void GetRandomField(int*& fieldState, int& hideButtIndex)
{
	//Получать случайное состояние игрового поля пока оно не пройдет проверку на собираемость
	int mas[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
	
	do
	{
		copy(&mas[0], &mas[MAP_SIZE], fieldState); //Заполнить массив значениями - 1
		GenerateMas(fieldState, hideButtIndex); //Получить массив неповторяющихся значений
	} while (!IsWinPossible(fieldState)); 
}

//Функция проверки состояния на собираемость
bool IsWinPossible(int* genField)
{
	/*Анализ собираемости поля
	Поле собираемое, если inv + k есть четное число

	inv - последовательно анализируя каждую ненулевую клетку поля
	считать количество предешествующих клеток, которые по значению
	больше анализируемой

	k - позиция ненулевой клетки деленная на 4 + 1 (i/4 + 1)
	*/

	bool res;
	int inv = 0, i = 0, j = 0;

	//Определение inv
	for (; i < MAP_SIZE; ++i)
		if (genField[i])
			for (int j = 0; j < i; ++j)
				if (genField[j] > genField[i])
					++inv;

	//Определение k
	for (int i = 0; i < MAP_SIZE; ++i)
		if (genField[i] == 0)
		{
			inv += 1 + i / 4;
			break;
		}

	!(inv & 1) ? res = true : res = false; //проверка на честность

	return res;
}
