//Функция получения случайного состояния игрового поля (размерностю 4x4). Состояния игрового поля, при которых сборка невозможна отсекаются
//Генерируемое поле представлено как одномерный массив.
void GetRandomField(int*& fieldState, int& hideButtIndex)
{
	//Получать случайное состояние игрового поля пока оно не пройдет проверку на собираемость
	int mas[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
	
	do
	{
		copy(&mas[0], &mas[MAP_SIZE], fieldState); //Заполнить массив значениями - 1
		GenerateMas(fieldState, hideButtIndex); //Получить массив неповторяющихся значений
	} while (!IsWinPossible(fieldState)); 
}

//Функция для генерирации новый массива неповторяющихся значений
void GenerateMas(INT* mas, INT& hideInd)
{
	INT i = 0, j, tmp;
	BOOL bReGen;

	/*Генерация одномерного массива неповторяющихся значений от 0 до BUTTONS_AMOUNT-1 (15 значений)*/
	while (i < BUTTONS_AMOUNT)
	{
		bReGen = FALSE; //перегенерация - не нужна

		tmp = rand() % 16; //получить псевдо-случайное число

		/*Сравниваем число в tmp с текущим состоянием массива.
		Если число в tmp равно одному из значений массива необходима "перегенерация"*/
		for (j = 0; j < i && !bReGen; j++)
			if (tmp == mas[j] && i != j)
				bReGen = TRUE;

		if (bReGen)            //Если необходима перегенерация
			continue;          //счетчик i не увеличивается и цикл при текущем i выполняется снова
		else
		{
			mas[i++] = tmp;   //Иначе, записать в массив неповторяющееся значение и сдвинуть счетчик элементов
			/*Зафиксировать индекс, который соответствует нулевому значению в массиве 
			(клетка, которой соответствует 0 должна быть скрыта)*/
			if (!tmp)         
				hideInd = tmp;
		}
	}
}

//Функция проверки состояния на собираемость
bool IsWinPossible(int* genField)
{
	/*Анализ собираемости поля
	Поле собираемое, если inv + k есть четное число

	inv - последовательно анализируя каждую ненулевую клетку поля
	считать количество предешествующих клеток, которые по значению
	больше анализируемой

	k - позиция ненулевой клетки деленная на 4 + 1 (i/4 + 1)
	*/

	bool res;
	int inv = 0, i = 0, j = 0;

	//Определение inv
	for (; i < MAP_SIZE; ++i)
		if (genField[i])
			for (int j = 0; j < i; ++j)
				if (genField[j] > genField[i])
					++inv;

	//Определение k
	for (int i = 0; i < MAP_SIZE; ++i)
		if (genField[i] == 0)
		{
			inv += 1 + i / 4;
			break;
		}

	!(inv & 1) ? res = true : res = false; //проверка на честность

	return res;
}
