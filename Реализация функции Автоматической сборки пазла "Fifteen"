/*Алгоритм автосборки основан на рекурсивном алгоритме IDA-Star (обхода дерева состояний с отсечением состояний, 
  эвритическая оценка которых превышает значение порога (подробнее см. README.txt)*/

/*----------Алгоритм поиска кратчайшего пути------------*/
//Функция-член IdaStar класса Field.
      hMain - хендлер главного окна (используется для предотвращения зависания главного окна программы в процессе сборки)

int Field::IdaStar(HWND hMain)
{	
//Установить порог поиска, равный эвристической оценке начального состояния перед сборкой
int treshold = this->GetDisance();
int res = -1;
//Пока не найдено решение
while (res != FOUND)
{	//Положить в открытый список начальное состояние
	openList.push_back(*this);
	res = Search(openList, 0, treshold, hMain); //Искать решение
	if (res == NOT_FOUND)
		return NOT_FOUND;
	else if(res != FOUND)
	{
		treshold = res; //Если решение не найдено, но оно есть (т.к. не произошел возврат NOT_FOUND) увеличить порог и искать решение заново
	}
	//Очистка открытого списка
	vector<Field>().swap(openList); 
}
     return FOUND;
}

//Порог служит для:
  1) предотвращение развертывания узлов, стоимость которых превышает значение порога равного эвристической оценке стартового поля, что влечет за собой поиск частного решения за минимальное количество ходов;
  2) предотвращение зацикливания поиска частного решения. Уже развернутые ранее вершины будут иметь стоимость, которая превышает порог развертывания. Это позволяет избежать хранения списка закрытых вершин и избежать времени затраченного на поиск вершины в списке закрытых вершин, памяти для хранения развернутых вершин в списке).

/*-----Рекурсивная функция поиска терминального состояния----------*/
      lst - список открытых состояний (ожидающих рассмотрения)
      g - вес хода
      tresh - порог

int Field::Search(vector<Field>& lst, int g, int tresh, HWND hMain)
{
//0. Обрабатывать сообщения во время работы алгоритма
MSG message;
if (PeekMessage(&message, hMain, 0, 0, PM_REMOVE))
{
	TranslateMessage(&message);
	DispatchMessage(&message);
}

//1. Создать узел (берется последний элемент открытого списка)
Field node(*(lst.end() - 1));

//2. Проверить его стоимость
int cost = g + node.GetDisance(), min, next;

//3. Если стоимость превышает порог вернуть стоимость
if (cost > tresh)
	return cost;
  
//4. Если текущий узел это терминальное состояние
if (node.IsFinish())
{
	return FOUND; //вернуть FOUND
}

//5. Минимальная стоимость
min = INT_MAX;

//6. Сформировать список дочерних состояния и анализировать каждое
vector<Field> chList;
node.GetChildren(chList);
for (Field child : chList)
{	
	//Если открытый список не содержит дочернее состояние
	if (!node.IsListContain(child, openList))
	{	//Положить его в открытый и выполнить поиск для него
		openList.push_back(child);
		next = Search(openList, child.GetMove(), tresh, hMain);
		if (next == FOUND)
		{	//Если найдено терминальное поле добавить его в закрытый список и вернуть FOUND
			solutionList.push_back(child);
			return FOUND;
		}
		if (next < min) //Зафиксировать минимальную стоимость узла, превышающего порог treshold
			min = next;
			openList.pop_back(); //Вытолкнуть из открытого списка проанализированный узел
		}
	}
	return min;
}
